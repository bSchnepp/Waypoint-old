For now, NTFS is the "native" filesystem for Waypoint.

We'll replace NTFS with a brand new filesystem called "FeralFS", again, aimed at fast lookup times and for use on SSDs. Goal is to get
as much performance as possible out of the filesystem for applications using it. Writing to it is less of an issue, we care about reads more.

(Generally, games read FAR more data from the disk than they do writing save files and all. We care about being the best OS for games to run on. As such, we need to implement
some kind of lookup table to silently put near an executable so if it calls a specific file a bunch of times, it can just directly get it instead of fumbling around the filesystem.
Say "A:/Users/Brian/Games/Mars Affection 2/me2.pro" calls "A:/Common/Games/Electronic Computer Games/me2/data.bzp" a bunch of times, we just create a (hidden) file called "sys$lookupcache.lkp" and 
make it easy to find again, by just getting it's relevant page/sector/thing, slapping it in there, and saying "here it is!". Figure out how to avoid actually writing this to disk..?)


System calls that need to be implemented for NTFS:

FsCreateFile(...)
FsDeleteFile(...)
FsRenameFile(...)
FsTransferFile(...)
FsOpenFile(...)
FsCloseFile(...)
FsExecuteFile(...)
FsExtractArchive(...)
FsArchiveDirectory(...)
FsCreateDirectory(...)
FsDeleteDirectory(...)
FsRenameDirectory(...)
FsTransferDirectory(...)
FsRenameDirectory(...)
FsAssignPermission(...)

FsGetVolumeSize(...)
FsGetVolumeUsedSize(...)
FsGetVolumeFreeSize(...)

FsMountLetter(...)
FsMountPartition(...)
FsUnmountLetter(...)
FsUnmountPartition(...)

FsMountToDirectory(...)
FsUnmountFromDirectory(...)

[todo on this list]

Things we'll implement in order:

Filesystem [test by dumping names of files in essentially a prototype for "tree" with printk)

Memory management [Not 100% sure how to really test actually.]

TCP/IP and other networking stuff port from FreeBSD, then "Feralify" it. Ping a public thing or something and show that indeed, networking works.
	(Any further changes we need to make for networking, we can just do ourselves. IP is going to be the hard standard to comply with if anything.)

Graphics driver port from Mesa/Gallium. Wrap around it, since once it's in the kernel, we'll probably be pulling changes into the kernel, instead of improving whatever happens to be mainline at that time.
	Show a "booting Waypoint" screen or something, in it's full black-and-yellow "gamery" color scheme glory. 
	Re-do the hardware initialization and kernel setup as a bunch of messages flying across the boot screen or something. Test on underclocked hardware, and weak hardware and everything.
	I'm told what you really want is a desktop and a GUI over anything else. Don't worry about how the file explorer or anything look (they can always be replaced), make the desktop (just it) AWESOME.
	Icons can be arbitrarilly sized ala GNOME, positioned arbitrarilly, plenty of features, we use a pie menu instead of drop down box (try to feel "gamery"), circle-menu where icons don't work, etc.
		Force hexagons wherever we can. Close/Minimize/Maximize buttons must be hexagons. Red for close, green for minimize, blue for maximize. Always close-min-max in that order. Right of frame.
		"caption" (title) of frame is left of frame, with it's "File Edit etc. etc." menu in the middle. Overflow is hidden with an arrow. to open the rest. Split frame sections into thirds.
		Center section should be well, centered. 
	If we want to be cool, maybe add something so that the desktop, in essence, is essentially a web page stored on the local system. From there, we can have fun stuff like effects on icons and all.
		Maybe animated wallpapers?

Do things to do SMP. The OS should be fine with using many cores. We actually really need this, since I'm switching testing hardware from a N3700 to an overclocked R7 1700X.

Implement svchost.pro, csrss.pro, console.pro (OS shell or command line, same thing.), waylogin.pro, etc. etc. Also create the standard C library implementation. 
Possibly fork Bionic..? Probably [most likely] write a brand new one?
	waylibc better be under a permissive license, ideally something *really* permissive like CC0 or zlib.
This is essentially the core parts of the system we actually need.

Integrated GUI/"framing" system.

Port over FreedomCore, clang, nasm, git, a web browser (or just create a one w/ partial HTML 5 compliance, reasonable CSS 3 compliance, and juryrigging V8 on it.), and other tools needed to self-host.

Recompile Waypoint on Waypoint. Ensure it works as intended. Remove *NIX things when in the way and assume we're compiling on Waypoint from then on. This is going to take 8 years optimistically.

Implement Owaysys, which should be reasonably simple, as it's the closest to "the native API" you're going to get without being tied too closely to the OS.

[past here is the "no way this is any time soon at all. Maybe 8 - 12 years of development time optimistically?"]
When that's stable, implement the POSIX personality of the kernel. Use this to port other applications which were hard to directly port to Waypoint. From here, use mainline clang instead of the fork earlier.

Start building up the distributed parts of the kernel. Get another machine (or virtual machine) running Waypoint, and create "Gamer Mode" which dumps unneeded programs (ones not asking for lots of GPU power through Vulkan) to be executed on other hardware and have results sent back, in order to allocate more CPU time to games.

Port over other applications, things, etc. we'll want.

Create an IDE for Waypoint which is specifically built with compiling and building Waypoint itself in mind, but also flexible and useful for non-OS programs and all. Tie it heavilly into Waypoint's GUI system. Ensure the only other OS a port of said IDE wouldn't be a waste of time doing would be a Linux (and by extension a FreeBSD) port. Tie it very closely with the OWaysys personality of the kernel.
Use undocumented functions if necessary.

Continue with Waypoint development from there into unknown land!!! (then beg game developers "please port your games to my OS now that it's stable!!!")

TODO: Move big chunks of this file somewhere else.
